---
title: 基础语法
date: 2024-06-06 19:07:58
order: 1
---

<script setup>
  import typeConversion from "/svg/java/javase/syntax/type-conversion.svg?raw";
  import priority from "/svg/java/javase/syntax/priority.svg?raw";
</script>

## 关键字、标识符、字面量

**关键字**：被 Java 语言赋予特定含义的单词。Java 关键字是 Java 语言保留供内部使用的，所以不能使用关键字作为变量名或方法名。特点：组成关键字的字母全部小写。

**保留字**：在 JDK 的新版本中可能提升为关键字。

### 关键字图表

|--|--|--|--|--|
|abstract |assert |boolean |break |byte |
|case |catch |char |class |const |
|continue |default |do |double |else |
|enum |extends |final |finally |float |
|for |goto |if |implements |import |
|instanceof |int |interface |long |native |
|new |package |private |protected |public |
|return |strictfp |short |static |super |
|switch |synchronized |this |throw |throws |
|transient |try |void |volatile |while |

### 关键字分类

- 数据类型：`byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean`、`void`
- 流程控制：`if`、`else`、`switch`、`case`、`default`、`while`、`do`、`for`、`break`、`continue`、`return`
- 访问权限：`public`、`protected`、`private`
- 修饰符：`abstract`、`final`、`static`、`synchronized`
- 面向对象：`class`、`new`、`extends`、`this`、`super`、`instanceof`、`interface`、`implements`
- 异常处理：`try`、`catch`、`finally`、`throw`、`throws`
- 包相关：`package`、`import`
- 保留字：`const`、`goto`
- 直接量：`true`、`false`、`null`
- 其他：`native`、`strictfp`、`transient`、`volatile`、`assert`

### 关键字详解

| 关键字         | 含义                                                                                         |
| -------------- | -------------------------------------------------------------------------------------------- |
| `byte`         | 基本数据类型之一，字节类型                                                                   |
| `short`        | 基本数据类型之一，短整数类型                                                                 |
| `int`          | 基本数据类型之一，整数类型                                                                   |
| `long`         | 基本数据类型之一，长整数类型                                                                 |
| `float`        | 基本数据类型之一，单精度浮点数类型                                                           |
| `double`       | 基本数据类型之一，双精度浮点数类型                                                           |
| `char`         | 基本数据类型之一，字符类型                                                                   |
| `boolean`      | 基本数据类型之一，布尔类型                                                                   |
| `void`         | 声明当前成员方法没有返回值                                                                   |
| `if`           | 条件语句的引导词                                                                             |
| `else`         | 用在条件语句中，表明当条件不成立时的分支                                                     |
| `switch`       | 分支语句结构的引导词                                                                         |
| `case`         | 用在 switch 语句之中，表示其中的一个分支                                                     |
| `default`      | 默认，例如，用在 switch 语句中，表明一个默认的分支                                           |
| `while`        | 用在循环结构中                                                                               |
| `do`           | 用在 do-while 循环结构中                                                                     |
| `for`          | 一种循环结构的引导词                                                                         |
| `break`        | 提前跳出一个块                                                                               |
| `continue`     | 回到一个块的开始处（一般用在循环中，跳出本次循环，开始下一次循环）                           |
| `return`       | 从成员方法中返回数据                                                                         |
| `public`       | 一种访问控制方式：共用模式                                                                   |
| `protected`    | 一种访问控制方式：保护模式                                                                   |
| `private`      | 一种访问控制方式：私用模式                                                                   |
| `try`          | 尝试一个可能抛出异常的程序块                                                                 |
| `catch`        | 用在异常处理中，用来捕捉异常                                                                 |
| `finally`      | 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块                                     |
| `throw`        | 抛出一个异常                                                                                 |
| `throws`       | 声明在当前定义的成员方法中所有需要抛出的异常                                                 |
| `package`      | 包                                                                                           |
| `import`       | 表明要访问指定的类或包                                                                       |
| `class`        | 类                                                                                           |
| `interface`    | 接口                                                                                         |
| `enum`         | 枚举                                                                                         |
| `const`        | 保留关键字，没有具体含义                                                                     |
| `final`        | 一般用来定义常量，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变 |
| `static`       | 表明具有静态属性                                                                             |
| `abstract`     | 表明类或者成员方法具有抽象属性                                                               |
| `new`          | 用来创建新实例对象                                                                           |
| `extends`      | 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口                                   |
| `this`         | 指向当前实例对象的引用                                                                       |
| `super`        | 表明当前对象的父类型的引用或者父类型的构造方法                                               |
| `instanceof`   | 用来测试一个对象是否是指定类型的实例对象                                                     |
| `implements`   | 表明一个类实现了给定的接口                                                                   |
| `synchronized` | 表明一段代码需要同步执行                                                                     |
| `volatile`     | 表明两个或者多个变量必须同步地发生变化                                                       |
| `transient`    | 声明不用序列化的成员域                                                                       |
| `native`       | 用来声明一个方法是由与计算机相关的语言（如 C/C++/FORTRAN 语言）实现的                        |
| `assert`       | 用来进行程序调试                                                                             |
| `strictfp`     | 用来声明 FP_strict（单精度或双精度浮点数）表达式遵循 IEEE 754 算术规范                       |
| `goto`         | 保留关键字，没有具体含义                                                                     |
| `null`         | 一个空引用（注意：null 从技术上讲是一个直接量，而不是关键字，但是不推荐用作标识符）          |

### 标识符

标识符就是由一些字符、符号组合起来的名称，用来给类、变量、方法进行命名的。

**标识符命名规则：**

- 标识符可以由字母、数字、下划线、美元符组成，其中不能以数字开头。
- 标识符不能是 Java 关键字和保留字，但可以包含关键字和保留字。
- 大小写敏感，且长度无限制。

**标识符命名规范：**

- 所有变量、方法、类名需要做到见名知义。
- 成员变量、局部变量、方法名：首字母小写，满足驼峰模式
- 类名：首字母大写，满足驼峰模式。
- 常量：字母全部大写，单词之间使用下划线分割。

Java 不采用 ASCII 字符集，而是采用 Unicode 字符集。因此，这里的字母不仅仅表示英文，还包括汉字等。但不建议使用汉字来定义标识符。

### 字面量

字面量：直接写出来的人可以理解的数据。

| 字面量类型   | 描述                 | 举例                    |
| ------------ | -------------------- | ----------------------- |
| 字符串字面量 | 用双引号括起来的内容 | "HelloWorld"、"hello"   |
| 整数字面量   | 不带小数的数字       | 666、-88                |
| 小数字面量   | 带小数的数字         | 13.14、-5.21            |
| 字符字面量   | 用单引号括起来的内容 | 'A'、'0'、'我'          |
| 布尔字面量   | 布尔值，表示真假     | 只有两个值：true、false |

## 变量和常量

- 变量：就是在程序的执行过程中，其值是可以在一定范围内发生改变的量。它表示内存中的一个存储区域，不同的变量，数据类型不同，占用的空间大小也不一样。
- 变量的组成规则：
  - 数据类型：必须对变量进行限定。如何限定呢？使用数据类型。
  - 变量名：在运算时不可能拿着这个空间去运算，真正运算时使用的是该空间中的值，所以应该为该空间起一个名字。
  - 初始化值：即使有数据类型和变量名了，但是如果没有值，这个空间就是一个垃圾空间，没有任何意义。
- 定义变量的格式：`数据类型 变量名 = 初始化值;`

### 变量声明

在 Java 中，每个变量都有一个类型。在声明变量时，先指定变量的类型，然后是变量名。

```java
double salary;
int vacationDays;
long earthPopulation;
boolean done;
```

- 变量名必须是一个以字母开头并由字母或数字构成的序列
- 变量名的长度基本上没有限制
- 不能使用 Java 保留字作为变量名
- 在 `Java9` 中，单下划线`_`不能作为变量名
- 可以在一行中声明多个变量 `int i,j;`。不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。

### 变量初始化

声明一个变量之后，必须用赋值语句对变量进行显式初始化。千万不要使用未初始化的变量的值，否则会报错。

要想对一个已经声明过的变量进行赋值，就需要将变量名放在等号（=）左侧，再把一个适当取值的 Java 表达式放在等号的右侧。也可以将变量的声明和初始化放在同一行中。

在 Java 中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。

```java
// 初始化方式一
int vacationDays;
vacationDays = 12;
// 初始化方式二
int vacationDays = 12;

// 整数类型
byte num1 = 127;
short num2 = 32767;
int num3 = 2147483647;
long num4 = 9223372036854775807L;
float num5 = 3.14F;
double num6 = 3.14D;

// 字符类型
char c1 = 'a';
char c2 = '中';
char c3 = '\u0061';
char c4 = '\n';

// 布尔类型
boolean b1 = true;
boolean b2 = false;
```

::: details 变量的正确写法和错误方法

```java
int x = 10; // 定义变量
int x = 20; // 错误：不能有同名的

int y;
System.out.println(y); // 错误：使用变量前，变量必须已经初始化

int z;
z = 30;
System.out.println(z); // 正确的形式

int a = 10; int b = 20; int c = 30; // 没有错误，但是不建议，不要写在一行上
//建议的写法
int a = 10;
int b = 20;
int c = 30;

int d, e; // 正确：相当于定义了 int d 和 int e
d = 40;
e = 50;

int f, int g; // 错误的写法
int f; int g; //正确的写法，但不建议，不要写在一行上

int a, b;
a = b = 10; // 正确：这种赋值语法没问题，但不建议
Sysout.out.println(a); // 10
Sysout.out.println(b); // 10
```

:::

### 变量的分类

Java 中的变量一般分为以下前两种（严格的讲分为三种）：

- 成员变量：指在方法外部，类的内部定义的变量。
  - 如果不自行初始化，它会自动初始化该类型的默认初始值。
  - 成员变量随类实例的存在而存在：对象创建，成员变量也跟着创建；对象消失，成员变量也跟着消失。
  - 类变量则随类的存在而存在：类被加载，类变量就有效；类被卸载，类变量就消失。
  - 对象实例可以访问类变量：同一个类中的所有实例访问类变量时，实际上访问的还是该类的同一个变量。
  - 同一个类中，不能定义两个同名的成员变量。即使一个是类变量、一个是实例变量也不行。
- 局部变量：在方法定义中或者方法声明上的变量都称为局部变量。
  - 局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化（形参除外）。
  - 同一个类中，不能定义两个同名的局部变量。方法局部变量和形参也不能同名。
  - 局部变量存储在方法的栈内存中，无需系统垃圾回收，随方法或代码块的运行结束而结束。
- 静态变量：static 关键字修饰的成员变量，该变量会被所有对象共享使用。
  - 随着类的加载而加载
  - 优先于对象存在
  - 被类的所有对象共享
  - 可以通过类名调用

### 成员变量-局部变量

|                    | 成员变量             | 局部变量                           |
| ------------------ | -------------------- | ---------------------------------- |
| 在类中的位置不同   | 类中定义的变量       | 方法或代码块中定义的变量           |
| 在内存中的位置不同 | 堆内存（heap）       | 栈内存（stack）                    |
| 是否有默认值       | 有                   | 没有；变量没有初始化会报错         |
| 代码作用范围       | 当前类的方法         | 当前一个方法或代码块               |
| 作用时间不同       | 当前对象从创建到销毁 | 定义变量到所属方法或代码块执行完毕 |

成员变量和局部变量的区别：

- 在类中的位置不同
  - 成员变量：类中方法外
  - 局部变量：方法内或者方法声明上
- 在内存中的位置不同
  - 成员变量：堆内存
  - 局部变量：栈内存
- 生命周期不同
  - 成员变量：随着对象的存在而存在，随着对象的消失而消失
  - 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
- 初始化值不同
  - 成员变量：有默认的初始化值
  - 局部变量：没有默认的初始化值，必须先定义、赋值，才能使用

### 成员变量-静态变量

|                  | 静态变量                                       | 成员变量                                           |
| ---------------- | ---------------------------------------------- | -------------------------------------------------- |
| 所属不同         | 静态变量属于类，所以也称为为类变量             | 成员变量属于对象，所以也称为实例变量（对象变量）   |
| 内存中位置不同   | 静态变量存储于方法区的静态区                   | 成员变量存储于堆内存                               |
| 内存出现时间不同 | 静态变量随着类的加载而加载，随着类的消失而消失 | 成员变量随着对象的创建而存在，随着对象的消失而消失 |
| 调用不同         | 静态变量可以通过类名调用，也可以通过对象调用   | 成员变量只能通过对象名调用                         |
| 是否有默认值     | 有                                             | 有                                                 |

### 常量

在 Java 中，利用关键字 `final` 指示常量。关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。

```java
public class ConstantsClass {
  public static final double CD_PER_INCH = 3; // 定义类常量

  public static void main(String[] args) {
    final double CM_PRE_INCH = 2.54; // 定义普通常量
  }
}
```

在 Java 中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为**类常量**。可以使用关键字 `static final`设置一个类常量。需要注意，类常量的定义位于 main 方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量。

Java 中常量分类：

- 字面值常量
  - 字符串常量：用双引号括起来的内容
  - 整数常量：所有整数
  - 小数常量：所有小数
  - 字符常量：用单引号括起来的内容
  - 布尔常量：只有 true 和 false
  - 空常量：null
- 自定义常量

## 数据类型和数据类型转换

Java 是一种强类型语言，这就意味着必须为每一个变量声明一种类型。JAVA 中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA 中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。

![数据类型](/svg/java/javase/syntax/data-type.svg)

### 基本数据类型

| 类型      | 存储需求      | 取值范围                                              | 指数范围         |
| --------- | ------------- | ----------------------------------------------------- | ---------------- |
| `byte`    | 8 位          | -128~127                                              | -2^7^ ~ 2^7^-1   |
| `short`   | 16 位         | -32768~32767                                          | -2^15^ ~ 2^15^-1 |
| `int`     | 32 位（默认） | -2147483648~2147483647（约 21 亿；10 位数）           | -2^31^ ~ 2^31^-1 |
| `long`    | 64 位         | -9223372036854775808 ~ 9223372036854775807（19 位数） | -2^63^ ~ 2^63^-1 |
| `float`   | 32 位         | ±3.40282347E+38F（有效位数为 6~7 位）                 | 3.4x10^38^       |
| `double`  | 64 位（默认） | ±1.79769313486231570E+308（有效位数为 15 位）         | 1.79x10^308^     |
| `char`    | 16 位         | 0-65535，默认值为空字符（\u0000）                     |                  |
| `boolean` | 8 位          | true 或者 false，默认值 false                         |                  |

- 随便写一个整数字面值，默认是 int 类型的。如果希望随便写一个整数默认是 long 型的必须在数据后加 `L` 或 `l` 表示。
- 随便写一个小数字面值，默认是 double 类型的。如果希望这个小数是 float 类型的，必须在数据后加 `F` 或 `f` 表示。
- 当然也可以在浮点数值后面添加后缀 `D` 或 `d`，显示声明为 double 类型值，例如 3.14D。

### 数据类型转换

」
**自动类型转换**：容量小的数据类型可以自动转换为容量大的数据类型。当一个算数表达式中包含多个基本数据类型的值时，整个算数表达式的数据类型将会发生自动提升。

- 所有的 byte、short、char 类型将被提升到 int 类型
- 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型
- 表达式的最终结果的类型是由表达式中的最高类型决定的

**强制类型转换**：由于类型范围大的变量，不能直接赋值给类型范围小的变量，会报错。所以需要强制类型转换，强行将类型范围大的变量赋值给类型范围小的变量。

强制类型转换格式：`数据类型 变量2 = (数据类型) 变量1;`。注意：不要随便的去使用强制转换，因为它隐含了精度损失问题。

- 强制类型转换可能造成数据（丢失）溢出
- 浮点型转换成整型，直接丢掉小数部分，保留整数部分返回

<svg-image :svg="typeConversion" />

::: details 数据类型转换案例

```java
// 案例一
byte b1 = 3, b2 = 4, b;
b = b1 + b2; // 报错：变量运算。这个涉及变量相加，类型由 byte 提升为 int，所以报错
b = 3 + 4; // 正常：常量运算。这个会先把常量结果计算出来，然后看结果是否在 byte 的范围内，如果在就不报错
// 变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题
// 常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。

// 案例二
short s = 1;
s = s + 1; // 这个会报错：等号赋值运算符的右边包含变量运算，此时会存在变量提升，s+1 变为了 int 类型

short s = 1;
s += 1; // 正确写法：+=运算符其实隐含了一个强制类型转换。s+=1，等价于 s = (s的数据类型)(s+1);

// 案例三
byte c = (byte) (b1 + b2);
// 强制数据类型转换
// 注意：不要随意的去使用强制转换，因为它隐含了精度损失的问题

// 案例四
byte b = (byte) 130;
//结果是多少呢?
System.out.println(b);
// 分析过程：我们要想知道结果是什么，就应该知道是如何进行计算的。而我们又知道计算机中数据的运算都是补码进行的。而要得到补码，首先要计算出数据的二进制。
// A: 获取130这个数据的二进制。00000000 00000000 00000000 10000010
// B: 做截取操作，截成byte类型的了。10000010 这个结果是补码。
// C: 已知补码求原码。1111110 即 -126
```

:::

## 八种基本数据类型

### 整数类型

整数用于表示没有小数部分的数值，它允许使用负值。在 Java 中有 4 种整数类型：`byte`、`short`、`int`、`long`。Java 中整数类型一般默认为 int 型。

整数的下划线表示法：下划线表示法从 Java7 开始，可以为数字字面量添加下划线。下划线只是为了让人更易读，Java 编译器会去除这些下划线。例如 1_000_000（或 0b1111_0100_0100_0000）表示 100 万。

整数的进制表示法：

- 二进制（逢二进一，以 `0b` 或 `0B` 开头）
- 八进制（逢八进一，以 `0` 开头）
- 十进制（逢十进一，默认进制）
- 十六进制（逢十六进一，以 `0x` 或 `0X` 开头）

```java
byte a = 0b100; // 声明一个二进制 byte 型变量 a，给定值为4（二进制为100），（二进制以 0b 标识）
short b = 0100; // 声明一个八进制 short 型变量 b，给定值为 144（八进制为 100），（八进制以 0 标识）
int c = 0x100; // 声明一个十六进制 int 型变量 c，给定值为 400（十六进制为 100），（十六进制以 0x 标识）
```

### 浮点类型

::: tabs
== 浮点类型
浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型：`float`、`double`，默认为 double 类型。

- double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值）。在很多情况下，float 类型的精度（6~7 位有效数字）并不能满足需求。实际上，只有很少的情况适合使用 float 类型，例如，需要单精度数的库，或者需要存储大量数据时。
- float 类型的数值有一个后缀 `F` 或 `f`（例如，3.14F）。没有后缀 F 的浮点数值（如 3.14）总是默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d，例如，3.14D。

注意：浮点类型不精确，存在舍入误差，数字不能精确表示，所以不要用浮点类型进行数值比较。如果必须进行比较，请使用 `BigDecimal` 进行运算和比较。
== 浮点类型的表示形式

- 十进制数表示形式；如：3.14、314.0、0.314
- 科学计数法表示形式；如：3.14E0、3.14E2、3.14E-1

**可以使用十六进制表示浮点数值**：浮点数利用科学计数法来表达实数，即用一个尾数、一个基数、一个指数以及一个表示正负的符号来表达实数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。比如 123.45 用十进制科学计数法可以表达为 1.2345 × 10^2。1.2345 为尾数（尾数中数字的个数称为精度），10 为基数，2 为指数。

**还可以使用十六进制表示浮点数值**：在十六进制表示法中，使用 p 表示指数，而不是 e（e 是一个十六进制数位）。注意，尾数采用十六进制，指数采用十进制，且指数的基数是 2。比如 0.125=2^-3 可以表示成 0×1.0p-3。
== 浮点数的由来
小数包括整数部分和小数部分，其中根据小数点的位置又可细分为定点数和浮点数。由于定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数，所以出现了浮点数。

- 定点数：小数点固定的位于实数所有数字中间的某个位置；前面表示整数部分，后面表示小数部分
- 浮点数：小数点的位置不固定

Java 平台上的浮点数类型 float 和 double 采纳了 IEEE 754 标准中所定义的单精度 32 位浮点数和双精度 64 位浮点数的格式。

IEEE 754 指定两种基本的浮点格式：单精度和双精度

- IEEE 单精度格式具有 24 位有效数字精度，并总共占用 32 位
- IEEE 双精度格式具有 53 位有效数字精度，并总共占用 64 位

| 浮点类型        | 符号位 | 指数    | 尾数    |
| --------------- | ------ | ------- | ------- |
| 单精度 `float`  | 1 bit  | 8 bits  | 23 bits |
| 双精度 `double` | 1 bit  | 11 bits | 52 bits |

== 特殊的浮点数值

- 正无穷大：`Double.POSITIVE_INFINITY` 或者 `Float.POSITIVE_INFINITY`
- 负无穷大：`Double.NEGATIVE_INFINITY` 或者 `Float.NEGATIVE_INFINITY`
- NaN：`Double.NaN` 或者 `Float.NaN`

使用场景：

- 使用一个正数除以 0 将得到正无穷大
- 使用一个负数除以 0 将得到负无穷大
- 如果一个整数值除以 0，则会抛出一个异常（ArithmeticException:/by zero 除以 0 异常）
- 计算 0/0 或 对一个负数开方将得到 NaN

所有的正无穷大数值都是相等的。所有负无穷大数值都是相等的。NaN 不与任何数值相等，甚至和 NaN 都不相等。
== float 在内存中存储方式
一个浮点数有 2 部分组成：底数 m 和指数 e。但是指数可正可负，所以，IEEE 规定，此处算出的次方必须减去 127 才是真正的指数。因此 float 类型的指数可从-126 到 128。底数部分实际是占用 24bit 的一个值，但是最高位始终为 1，所以，最高位省去不存储，在存储中占 23bit。

- 底数部分：使用二进制数来表示此浮点数的实际值
- 指数部分：占用 8bit 的二进制数，可表示数值范围为 0-255

格式：`SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM`

S 表示浮点数正负；E 指数加上 127 后的值得二进制数据；M 底数。
== 举例：17.625 在内存中的存储

- 首先要把 17.625 换算成二进制：10001.101
  - 整数部分，除以 2，直到商为 0，余数反转
  - 小数部分，乘以 2，直到乘位 0，进位顺序取
- 在将 10001.101 右移，直到小数点前只剩 1 位：1.0001101 \* 2^4 因为右移动了四位

这个时候，我们的底数和指数就出来了：

- 底数：因为小数点前必为 1，所以 IEEE 规定只记录小数点后的就好。所以，此处的底数为：0001101
- 指数：实际为 4，必须加上 127（转出的时候，减去 127），所以为 131。也就是 10000011

符号部分是整数，所以是 0。综上所述，17.625 在内存中的存储格式是：`01000001 10001101 00000000 00000000`
:::

### 字符类型

由于计算机底层保存字符时，实际是保存该字符对应的编号。因此，char 类型的值也可直接作为整型值来使用，它相当于一个 16 位的无符号整数，表数范围是 `0~65535`。char 类型的变量和值完全可以参与加减乘除等数学运算，也可以比较大小——实际上都是用该字符对应的编码参与运算。

- char 类型的字面量值要用单引号括起来。例如 'A' 的编码值是 65
- char 类型的值可以使用 Unicode 编码表示，其范围从 \u0000 到 \uFFFF，表示 0~65535 之间的编码（前缀 u 表示 Unicode）
- char 类型还可以使用特殊字符的转义序列，这些转义序列都可以出现在加引号的字符字面量或字符串中

| 转义字符 | 说明              |
| -------- | ----------------- |
| \b       | 退格（backspace） |
| \t       | 制表符            |
| \n       | 换行              |
| \r       | 回车              |
| \"       | 双引号            |
| \'       | 单引号            |
| \\       | 反斜杠            |

### 布尔类型

布尔类型有两个值：true 和 false，用来判断逻辑条件

- 整型值和布尔值之间不能相互转换。注意：不能用 0 或 非 0 的整数代替 true 和 false
- 其他基本数据类型的值不能转换成 boolean 类型

## 运算符及其优先级

<svg-image :svg="priority" />

### 算术运算符

算术运算符：算数运算符用在数学表达式中，它们的作用和在数学中的作用一样。

二元运算符：一般用在计算上（就和计算器计算数一样）

- `+`（加）：加法运算
- `-`（减）：减法运算
- `*`（乘）：乘法运算
- `/`（除）：除法运算。注意：与数学中一样，0 不能作为除数
  - 整数相除只能得到整数，如果想得到小数，必须把数据变化为浮点数类型
  - 除法获取的是除法操作的商，取余操作获取的是除法操作的余数
- `%`（取余）：取余的意思顾名思义也就是除过后的余数

一元运算符：一般用在循环语句中

- `++`（自加运算）：每走一次自身加一
- `--`（自减运算）：每走一次自身减一

```java
int a = 1;
int b = 2;
int count = a + b; // 加法运算

int a = 1;
int b = 2;
int count = b - a; // 减法运算

int a = 1;
int b = 2;
int count = a * b; // 乘法运算

int a = 1;
int b = 2;
double count = a * 1.0 / b; // 除法运算，因为 1 除以 2 为小数，所以用 double 来接收
// 整数相除只能得到整数，如果就想得到小数，该怎么办呢？只需要把操作的数据中任意的一个数据变为浮点数。例如：System.out.println(a * 1.0/b);
System.out.println(a / b);
System.out.println(a * 1.0 / b);

int a = 4;
int b = 2;
int count = a % b; // 取余运算，4 除 2 可以除尽，计算结果 count 为 0

int a = 1;
int count = a++; // a 在前，所以 count 值为 1
int compute = ++a; // a 在后，所以 compute 值为 2

int b = 2;
int reckon = b--; // b 在前，所以 reckon 值为 2
int calculate = --b; // b 在后，所以 calculate 值为 1
```

### 关系运算符

关系运算符：关系运算符生成的是一个 `boolean` 类型的结果，一般用在判断语句中，它们的作用是运算两个对象值之间的关系，若关系是真的，则结果为 true，否则为 false。

- `>`（大于）：检查符号左边的值是否大于右边的值
- `<`（小于）：检查符号左边的值是否小于右边的值
- `>=`（大于等于）：检查符号左边的值是否大于或等于右边的值
- `<=`（小于等于）：检查符号左边的值是否小于或等于右边的值
- `==`（等于）：检查符号两侧的值是否相等
- `!=`（不等于）：检查符号两侧的值是否不相等

```java
int a = 1;
int b = 2;
boolean count = a > b; // a 的值不大于 b，所以 count 值为 false

int a = 1;
int b = 2;
boolean count = a < b; // a 的值小于 b，所以 count 值为 true

int a = 3;
int b = 2;
boolean count = a >= b; // a 的值大于 b，所以 count 值为 true

int a = 3;
int b = 2;
boolean count = a <= b; // a 的值不小于 b，所以 count 值为 false

int a = 2;
int b = 2;
boolean count = a == b; // a 的值等于 b，所以 count 值为 true

int a = 2;
int b = 2;
boolean count = a != b; // a 的值等于 b，所以 count 值为 false
```

### 位运算符

位运算符：位运算允许我们操作一个整数数据类型中的单个“比特”，也就是二进制位。位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果。

- `~`（取反）：翻转操作数的二进制的每一位，即 0 变为 1，1 变为 0（`~6=-7`）
- `&`（按位与）：运算符两边的操作数的二进制的对应位的值都为 1，则结果为 1，否则为 0（`6&3=2`）
- `|`（按位或）：运算符两边的操作数的二进制的对应位的值都为 0，则结果为 0，否则为 1（`6|3=7`）
- `^`（按位异或）：运算符两边的操作数的二进制的对应位的值相同，则结果为 0，否则为 1（`6^3=5`）
  - 异或的特点：一个数据对另一个数据位异或两次，该数本身不变
  - 例如：`int a=10, b=20; 10=(a^b^b); 20=a^b^a;`
- `<<`（按位左移运算符）：左操作数按位左移右操作数指定的位数（`3<<2=12;` 等价于 `3*2*2=12`：<< 把<<左边的数据乘以 2 的移动次幂）
  - 左边最高位丢弃，右边补齐 0
- `>>`（按位右移运算符）：左操作数按位右移右操作数指定的位数（`3>>1=1;` 等价于 `3/2=1`：>> 把>>左边的数据除以 2 的移动次幂）
  - 如果最高位是 0，左边补齐 0；如果最高位是 1，左边补齐 1
- `>>>`（按位右移补零操作符）：左操作数的值按右操作数指定的位数右移，移动得到的空位以 0 填充
  - 无论最高位是 0 还是 1，左边补齐 0（`3>>>1=1;` 等价于 `3/2=1`）

```java
int a = 60;   // 二进制：0011 1100
int b = 13;   // 二进制：0000 1101
// -----------------------------------
~a = -61;     // 二进制：1100 0011
a & b = 12;   // 二进制：0000 1100
a | b = 61;   // 二进制：0011 1101
a ^ b = 49;   // 二进制：0011 0001
a << 2 = 240; // 二进制：1111 0000
a >> 2 = 15;  // 二进制：0000 1111
a >>> 2 = 15; // 二进制：0000 1111

// 需求：两个变量值互换
// 方案一
int a = 10;
int b = 20;
int c = a;
a = b;
b= c;
// 方案二：异或的使用
int a = 10;
int b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### 逻辑运算符

逻辑运算符：逻辑运算符一般用于连接 boolean 类型的表达式，逻辑运算符能生成一个 `boolean` 布尔值（true/false）。一般用于判断语句上，与 C/C++ 不同，不可将一个非布尔值（0/1）当作布尔值在逻辑表达式中使用。

- `&&`（与/AND）：逻辑与，当且仅当操作符两侧的操作数都为真（true）时，条件才为真（true）
  - 可以理解为：当两边的值都相同时，结果为 true，否则为 false
- `||`（或/OR）：逻辑或，如果操作符两侧任意一侧为真（true）时，条件为真（true）
  - 可以理解为：当两边的值有一侧为 true 时，结果就为 true，否则为 false
- `!`（非/NOT）：逻辑非，用来反转操作数的逻辑状态，如果条件为 true，则逻辑非将得到 false
  - 可以理解为:取反，值为 false 结果就为 true，反之，值为 true 结果就为 false
- `&`（单“与”）：与逻辑与相同，但是不会短路
- `|`（单“或”）：与逻辑或相同，但是不会短路
- `^`（异或）：逻辑异或，只有两个操作数不同时才返回 true，两个操作数相同时返回 false

```java
boolean a = true;
boolean b = false;
int e = 5;
// 短路与（&&）
boolean count1 = a && b;    // 结果为 false
boolean boo1 = (e < 4) && (e++ < 10);    // 结果为 false，计算结束后 e 的值为 5
// 短路或（||）
boolean count2 = a || b;    // 结果为 true
boolean boo2 = (e > 4) || (++e < 10);    // 结果为 true，计算结束后 e 的值为 5
// 逻辑非
boolean count3 = !a;    // 结果为 false
// 非短路与（&）
boolean boo3 = (e < 4) & (e++ < 10);    // 结果为 false，计算结束后 e 的值为 6
// 非短路或（|）
boolean boo4 = (e > 4) || (++e < 10);    // 结果为 true，计算结束后 e 的值为 6
// 异或（^）
boolean count4 = a ^ b;    // 结果为 true

int a = 3;
int b = 4;
int c = 5;
// boolean b1 = ((x++ == 3) & (y++ == 4)); // x:4；y:5；true
// boolean b1 = ((x++ == 3) && (y++ == 4)); // x:4；y:5；true
// boolean b1 = ((++x == 3) & (y++ == 4)); // x:4；y:5；false
boolean b1 = ((++x == 3) && (y++ == 4)); // x:4；y:4；false
System.out.println("x:" + x);
System.out.println("y:" + y);
System.out.println(b1);
```

### 赋值运算符

赋值运算符：赋值运算符使用=（等于号）进行的，它的意思是“取消符号右边的值，将右边的结果复制到符号左边”。右边的值可以是任何常量、变量、表达式，只要能产生一个值就可以，但符号左边必须是一个明确类型的、已命名的变量。

- `=`（赋值）：赋值运算符，将符号右边的计算的结果值赋给左边的变量
- `+=`（和赋值）：和赋值运算符，将符号左边的值与右边的加起来再赋给左边的变量
- `-=`（减赋值）：减赋值运算符，将符号左边的值减去右边的值，再将结果赋给左边的变量
- `*=`（积赋值）：积赋值运算符，将符号左边的值与右边的相乘再赋给左边的变量
- `/=`（商赋值）：商赋值运算符，将符号左边的值除以右边的值，再将结果赋给左边的变量
- `%=`（取余赋值）：取余赋值运算符，将符号左边的值除以右边的值，再将除后的余数赋给左边的变量
- `&=`（按位与赋值）：按位与赋值运算符，将符号两边的值二进制比较，对应位的值都为 1，则结果为 1，否则为 0，再将结果赋给左边的变量
- `|=`（按位或赋值）：按位或赋值运算符，将符号两边的值二进制比较，对应位的值都为 0，则结果为 0，否则为 1，再将结果赋给左边的变量
- `^=`（按位异或赋值）：按位异或赋值运算符，将符号两边的值二进制比较，对应位的值相同，则结果为 0，否则为 1，再将结果赋给左边的变量
- `<<=`（左移赋值）：左移赋值运算符，将左边的值的二进制数向左移动右边值个单位，再赋给左边的变量
- `>>=`（右移赋值）：右移赋值运算符，将左边的值的二进制数向右移动右边值个单位，再赋给左边的变量

```java
// 有问题：精度损失；其中 s+1 计算出来的数据类型是 int，等号赋值给 short，类型不匹配
short s=1;
s = s+1;

// 没有问题：扩展的赋值运算符其实隐含了一个强制类型转换。s += 1 等价于 s = (s的数据类型)(s + 1);
short s=1;
s+=1;

int a = 10;        // 将 10 赋给 a
int b = 20;        // 将 20 赋给 b
int c = 5;        // 将 5 赋给 c

// 和赋值（+=）
a += b;        // 等价于：a = a + b;
// 减赋值（-=）
a -= b;        // 等价于：a = a - b;
// 积赋值（*=）
a *= b;        // 等价于：a = a * b;
// 商赋值（/=）
b /= a;        // 等价于：b = b / a;
// 取余赋值（%=）
b %= a;        // 等价于：b = b % a;
// 左移赋值（<<=）
c <<= 2;    // 等价于：c = c << 2;
// 右移赋值（>>=）
c >>= 2;    // 等价于：c = c >> 2;
// 按位与赋值（&=）
a &= b;        // 等价于：a = a & b;
// 按位或赋值（|=）
a |= b;        // 等价于：a = a | b;
// 按位异或赋值（^=）
a ^= b;        // 等价于：a = a ^ b;
```

### 三目运算符

三目运算符：三目运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋给变量（相当于简单的 if 语句）。

三目运算符：`布尔表达式 ? 表达式1 : 表达式2;`。根据表达式的计算返回一个 true 或者 false，如果是 true，就把表达式 1 作为结果返回；如果是 false，就把表达式 2 作为结果。

```java
int a = 10;
int b = 5;
int c = (a > b) ? (a - b) : (a + b); // 先判断 a 是否大于 b，如果大于则 a-b，否则 a+b
```

### 字符串连接符

字符串连接符：在定义字符串或输出字符串时，难免会遇到多个字符串拼接的问题，这时候就需要字符串连接符来拼接字符串。

字符串连接符（+）两侧的操作数只要有一个是字符串（String 类型），则系统会自动将另一个操作数转化为字符型，并连接。

```java
public class TestDemo{
  public static void main(String[] args){
      System.out.println("Hello" + "World"); // 使用字符串连接符连接两个字符串并在控制台输出
  }
}
```

### instanceof 关键字

instanceof 关键字：用在 if 语句中，一般用来判断一个对象是否是此类型的对象，返回值为 boolean 类型。

```java
// 语法
if(对象名 instanceof 类名){
    强制转换并调用
}

// 案例
public class TestDemo{
  public static void main(String[] args){
    if(stu instanceof Student){    // 判断 stu 是否是 Student 类型的
      代码体
    }
  }
}
```

## 权限修饰符

在 Java 中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。

|                                | `public` 公共的 | `protected` 受保护的 | `default` 默认的 | `private` 私有的 |
| ------------------------------ | :-------------: | :------------------: | :--------------: | :--------------: |
| 同一个类中                     |        ✔        |          ✔           |        ✔         |        ✔         |
| 同一个包中（包括子类和非子类） |        ✔        |          ✔           |        ✔         |                  |
| 不同包中的子类                 |        ✔        |          ✔           |                  |                  |
| 不同包中的非子类               |        ✔        |                      |                  |                  |

- “被 protected 修饰的成员可以被不同包中的子类访问”：这个意思是指子类内部可以直接使用父类 protected 成员进行调用，而不是在外部创建子类对象，通过子类对象访问父类 protected 成员（即不同包子类不可以通过创建父类对象，然后 `对象.方法名` 来调用）。
- 从父类继承的 protected 方法，如果子类没有重写，那么 `对象.方法` 是否可以调用要判断当前类和父类是否在同一个包内。如果子类重写了继承的 protected 方法，那么就可以使用 `对象.方法` 直接调用了。

::: tabs
== 修饰符总结

- 权限修饰符：public、protected、default（默认缺省的）、private
- 状态修饰符：static、final
- 抽象修饰符：abstract

== 针对类的相关修饰符
针对类的相关修饰符：public、default、final、abstract

- 权限修饰符：public、缺省的
- 状态修饰符：final
- 抽象修饰符：abstract

== 针对构造方法的相关修饰符
针对构造方法的相关修饰符：public、protected、缺省的、private

- 权限修饰符：public、protected、缺省的、private

== 针对成员变量的相关修饰符
针对成员变量的相关修饰符：public、protected、default、private、static、final

- 权限修饰符：public、protected、缺省的、private
- 状态修饰符：static、final

== 针对成员方法的相关修饰符
针对成员方法的相关修饰符：public、protected、缺省的、private、static、final、abstract

- 权限修饰符：public、protected、缺省的、private
- 状态修饰符：static、final
- 抽象修饰符：abstract

:::

## 流程控制语句

### if 语句

```java
// if语句形式一
if(boolean表达式) {
  语句体
}

// if语句形式二
if(boolean表达式) {
  语句体1;
}else {
  语句体2;
}

// if语句形式三
if(boolean表达式1) {
  语句体1;
}else if (boolean表达式2) {
  语句体2;
}
…
else {
  语句体n+1;
}
```

### switch 语句

switch 语句执行流程：首先计算出表达式的值。其次，和 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结束。最后，如果所有的 case 都和表达式的值不匹配，就会执行 default 语句体部分，然后程序结束掉。

witch 分支注意事项：

- switch 表达式类型只能是 `byte`、`short`、`int`、`char`，JDK5 开始支持枚举 `enum`，JDK7 开始支持 `String`
- case 给出的值不允许重复，且只能是字面量，不能是变量
- 不要忘记写 break，否则会出现穿透现象

switch 的穿透性：如果代码执行到没有写 break 的 case 块，执行完后将直接进入下一个 case 块执行代码（而且不会进行任何匹配），直到遇到 break 才跳出分支。

```java
// 表达式的取值：byte、short、int、char、enum、String
// case 后面跟的是要和表达式进行比较的值
// 语句体部分可以是一条或多条语句
// break 表示中断，结束的意思，可以结束 switch 语句
// default 语句表示所有情况都不匹配的时候，就执行该处的内容，和 if 语句的 else 相似
switch(表达式) {
  case 值1:
    语句体1;
    break;
  case 值2:
    语句体2;
    break;
  …
  default:
    语句体n+1;
    break;
}
```

- default 可以省略吗？可以省略。一般不建议。除非判断的值是固定的
- break 可以省略吗？可以省略，一般不建议。否则结果可能不是你想要的
- default 的位置一定要在最后吗？可以出现在 switch 语句任意位置
- switch 语句的结束条件：遇到 break 或者执行到程序的末尾

### 循环语句的组成

循环语句的组成：

- 初始化语句：一条或者多条语句，这些语句完成一些初始化操作
- 判断条件语句：这是一个 boolean 表达式，这个表达式能决定是否执行循环体
- 循环体语句：这个部分是循环体语句，也就是我们要多次做的事情
- 控制条件语句：这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束

### for 循环

for 循环：控制一段代码反复执行很多次。

- 初始化语句：一条或多条语句；这些语句用于完成一些初始化工作，初始化语句在循环开始之前执行
- 判断循环条件：这是一个 boolean 表达式，这个表达式能决定是否执行循环体
- 循环体语句：这个部分是循环的主体，如果循环条件允许，这个代码块将被重复执行
- 控制条件语句：这个部分在一次循环体执行结束后，对循环条件求值之前执行，通常用于控制循环条件中的变量，使得循环在合适的时候结束

逗号操作符：Java 中唯一用到逗号操作符的地方就是 for 循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分割的语句；通过使用逗号操作符，可以在 for 语句内定义多个变量，但是它们必须具有相同的类型。

```java
for (初始化语句;判断循环条件语句;控制条件语句) {
  循环体语句;
}

// 死循环
for (;;) {
  ……
}

// 逗号操作符
for (int i = 1, j = i + 10; i < 5; i++, j = i * 2) {
    System.out.println("i = " + i + " j = " + j);
}

for(int x = 0; x < 5; x++) {
  for(int y = 0; y <= x; y++){
    System.out.print("*");
  }
  System.out.println();
}
```

### while 循环

```java
初始化语句;
while(判断条件语句) {
  循环体语句;
  控制条件语句;
}

// 死循环
while (true) {
  ……
}
```

for 循环和 while 循环的区别：

- 控制条件语句所控制的那个变量，在 for 循环结束后，就不能再被访问到了，而 while 循环结束还可以继续使用，如果你想继续使用，就用 while，否则推荐使用 for。原因是 for 循环结束，该变量就从内存中消失，能够提高内存的使用效率。
- for 循环适合针对一个范围判断进行操作，while 循环适合判断次数不明确操作

### do-while 循环

do-while 循环至少会执行一次循环体

```java
初始化语句;
do {
  循环体语句;
  控制条件语句;
} while((判断条件语句);

// 死循环
do {
  ……
} while (true);
```

### break continue return

- break：表示结束当前所在的循环
  - 只能用于结束所在循环，或者结束所在 switch 分支的执行
  - 可以用在嵌套循环中跳出整个外部循环的并立即结束它
- continue：表示退出本次循环，然后进入下一次循环
  - 只能在循环中进行使用
  - 可以用在嵌套循环中跳出外部循环的当次执行，进入外部循环的下一次
- return：返回。其实它的作用不是结束循环的，而是结束方法的
  - 指定一个方法返回什么值
  - 直接结束当前的方法，并返回那个值。方法都结束了，循环也就结束了

```java
// break
OUT:for (int i = 0; i < 4; i++) {
  for (int j = 0; j < 5; j++) {
    ……
    break OUT;
  }
}

// continue
OUT:for (int i = 0; i < 4; i++) {
  for (int j = 0; j < 5; j++) {
    ……
    continue OUT;
  }
}

// return
for (int x = 0; x < 10; x++) {
  if (x == 2) {
    System.out.println("退出");
    // break;
    // continue;
    return;
  }
  System.out.println(x);
}
System.out.println("over");
```

### for-each 循环

for-each 是 JDK1.5 新增的功能，专门用于数组和容器；表示不必创建 int 变量去对由访问项构成的序列进行计数，for-each 会自动产生每一项（即 for-each 会读取数组或集合中所有的元素）。

- for-each 循环的对象必须是一个数组或者是一个实现了 Iterable 接口的类对象
- for-each 循环在遍历数组时不能修改数组中某元素的值
- for-each 循环仅适用于遍历，不涉及有关索引（下标）的操作
- for-each 循环只能处理一维数组；要想访问多维数组的元素，需要结合嵌套循环来使用

```java
for(数组元素类型 变量名: 数组){
  ……
}

// 案例
int[] arr = {1, 2, 3};
for (int a : arr) {
    System.out.println(a);
}
```

## 一维数组二维数组

数组是相同类型数据的有序集合。可以通过整型下标可以访问数组中的每一个值。数组既可以存储基本数据类型，也可以存储引用数据类型。

- 数组长度是确定的；数组一旦被创建，它的大小就是不可以改变的
- 其元素的类型必须是相同类型，不允许出现混合类型
- 数组类型可以是任何数据类型，包括基本数据类型和引用数据类型
- 数组变量属于引用类型，数组也是对象；数组中的元素相当于对象的属性

### 数组的使用

**声明数组**：声明数组时，并没有实例化任何对象，只有在实例化数组对象时，JVM 才会分配空间，这时才与长度有关。

- 格式 1：数据类型[] 数组名;
- 格式 2：数据类型 数组名[];

**数组的初始化**：Java 中的数组必须先初始化，然后才能使用。所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。

- 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值
  - 格式：数据类型[] 数组名 = new 数据类型[数组长度];
  - 数组长度其实就是数组中元素的个数
  - 动态初始化后数组中存放的是该数组类型的默认值
- 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度
  - 格式：数据类型[] 数组名 = new 数据类型[]{元素 1,元素 2,…};
  - 简化格式：数据类型[] 数组名 = {元素 1,元素 2,元素 3,…};

**使用数组**：

- 访问数组元素：通过在数组引用变量后紧跟一个方括号 `[]`，方括号里是数组元素的索引值
- 数组索引是从 0 开始的，最后一个数组元素的索引值是数组长度减 1
- 如果访问数组元素时指定的索引值小于 0，或者大于等于数组的长度，编译程序不会出现任何错误，但运行时出现异常：ArrayIndexOutOfBoundsException:N（数组索引越界异常）异常信息后的 N 就是程序员试图访问的数组索引
- 如果数组变量中没有存储数组的地址，而是 null，在访问数组信息时会出现空指针异常（NullPointerException）

### 二维数组

- 动态初始化（行固定列固定）：数据类型[][] 变量名 = new 数据类型[m][n];
  - m 表示这个二维数组有多少个一维数组；n 表示每一个一维数组的元素个数
- 动态初始化（行固定列变化）：数据类型[][] 变量名 = new 数据类型[m][];
  - m 表示这个二维数组有多少个一维数组；这一次没有直接给出一维数组的元素个数，可以动态的给出
- 静态初始化：数据类型[][] 变量名 = new 数据类型[][] { {元素…},{元素…},{元素…} };
- 静态初始化（简化版）：数据类型[][] 变量名 = { {元素…},{元素…},{元素…} };

### 数组的代码案例

```java
// 数组的定义
int[] a; // 定义一个 int 类型的数组 a 变量，推荐使用
int a[]; // 定义一个 int 类型的 a 数组变量

// 数组的初始化
int[] arr = new int[3]; // 动态初始化；定义了一个 int 类型的数组，这个数组中可以存放 3 个 int 类型的值
int[] arr = new int[]{1,2,3}; // 静态初始化；定义了一个 int 类型的数组，这个数组中可以存放 3 个 int 类型的值，并且值分别是1,2,3
int[] arr = {1,2,3}; // 静态初始化的简写形式

// 二维数组定义的方式一：动态初始化-行固定列固定
int[][] arr = new int[3][2]; // 定义了一个二维数组 arr
// 这个二维数组有 3 个一维数组，名称是 arr[0],arr[1],arr[2]
// 每个一维数组有 2 个元素，可以通过 arr[m][n] 来获取；表示获取第 m+1 个一维数组的第 n+1 个元素

// 二维数组定义的方式二：动态初始化-行固定列变化
int[][] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[3]
arr[2] = new int[1];

// 二维数组定义的方式三：静态初始化
int[][] arr =  new int[][]{ {1,2,3},{4,5,6},{7,8,9} };
// 二维数组定义的方式四：静态初始化-简化写法
int[][] arr =  { {1,2,3},{4,5},{6} };

// 二维数组的遍历
int[][] arr = { {1,2},{3,4},{5,6} };
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j]);
    }
    System.out.println();
}
```

## 局部代码块、构造代码块、静态代码块

在 Java 中，使用 `{}` 括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块（初始化代码块），静态代码块，同步代码块。

- 局部代码块：在方法中出现。限定变量生命周期，及早释放，提高内存利用率
- 构造代码块：在类中的成员位置出现，用 `{}` 括起来的代码
  - 每次调用构造方法执行前，都会先执行构造代码块
  - 作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化
- 静态代码块：在类中的成员位置出现，用 `{}` 括起来的代码，并加了 static 修饰
  - 作用：一般是对类进行初始化。在类加载的时候就执行，并且只执行一次

**代码块的执行顺序：静态代码块、构造代码块、构造方法**

## package 关键字

package 包其实就是文件夹，它的作用：对类进行分类管理。定义包的格式：`package 包名;`，多级包用 `.` 分开即可。

注意事项：

- package 语句必须是程序的第一条可执行的代码
- package 语句在一个 java 文件中只能有一个
- 如果没有 package，默认表示无包名

## import 关键字

import 导包：不同包下的类之间的访问，我们发现，每次使用不同包下的类的时候，都需要加包的全路径。比较麻烦。这个时候，java 就提供了导包的功能。注意：这种方式导入是到类的名称。虽然可以最后写 `*`，但是不建议。

导包格式：`import 包名;`

```java
package com.blog;

import org.example.Demo;

public class Main {
  public static void main(String[] args) {
    Demo demo1 = new Demo(); // import 导入方式
    org.example.Demo demo2 = new org.example.Demo(); // 全类名导入方式
  }
}
```

## 三种注释

在 Java 程序的编写过程中我们需要对一些程序进行注释，或者对一些代码进行解释，这样除了方便自己阅读以外，还能让别人更容易理解自己写的程序，所以我们需要用到注释。

可以将注释理解为程序的一部分，但是 Java 编译器是不会对注释进行编译的。注释的作用就相当于将注释掉的代码或者解释隐藏了起来，Java 编译器是看不到的。总而言之，注释的使用就是方便自己或者他人能更好的阅读。

Java 语言的注释主要有以下三种：`单行注释`、`多行注释`、`文档注释`

- 单行注释：使用 `//`，其注释内容从 // 开始到本行结尾
- 多行注释：使用 `/*` 和 `*/` 注释界定符将一段较长的注释括起来。注意：注释不能嵌套使用
- 文档注释：使用 `/**` 和 `*/` 注释界定符来自动地生成文档
  - Java 文档注释是一种功能强大的注释形式，如果在你所编写的程序中规范的添加文档注释，那么你就可以根据这些文档注释来生成一份系统正规的 API 文档
  - Java 使用 `javadoc` 工具来提取文档注释，生成十分专业的程序文档（API）。javadoc 输出的是一个 HTML 文件，可以使用自己的 Web 浏览器来查看该文档
  - API 的使用能更加容易让自己或者他人了解代码的结构与原理，而且在 API 中还能查看自己需要的类或接口与方法
  - **javadoc 工具默认只处理以 public 或 protected 修饰的类、接口、方法、成员变量、构造器和内部类之前的注释**

| javadoc 标签    | 描述                                                  | 示列                                                           |
| --------------- | ----------------------------------------------------- | -------------------------------------------------------------- |
| `@author`       | 标识一个类的作者                                      | @author description                                            |
| `@deprecated`   | 指明一个过期的类或成员                                | @deprecated description                                        |
| `@exception`    | 标志一个类抛出的异常                                  | @exception exception-name explanation                          |
| `@throws`       | 和 @exception 标签一样                                | The @throws tag has the same meaning as the @exception tag     |
| `@param`        | 说明一个方法的参数                                    | @param parameter-name explanation                              |
| `@return`       | 说明返回值类型                                        | @return explanation                                            |
| `@see`          | 指定一个到另一个主题的链接                            | @see anchor                                                    |
| `@since`        | 标记当引入一个特定的变化时                            | @since release                                                 |
| `@version`      | 指定类的版本                                          | @version info                                                  |
| `@serial`       | 说明一个序列化属性                                    | @serial description                                            |
| `@serialData`   | 说明通过 writeObject() 和 writeExternal()方法写的数据 | @serialData description                                        |
| `@serialField`  | 说明一个 ObjectStreamField 组件                       | @serialField name type description                             |
| `{@docRoot}`    | 指明当前文档根目录的路径                              | Directory Path                                                 |
| `{@inheritDoc}` | 从直接父类继承的注释                                  | Inherits a comment from the immediate surperclass.             |
| `{@link}`       | 插入一个到另一个主题的链接                            | {@link name text}                                              |
| `{@linkplain}`  | 插入一个到另一个主题的链接，但是该链接显示纯文本字体  | Inserts an in-line link to another topic.                      |
| `{@value}`      | 显示常量的值，该常量必须是 static 属性                | Displays the value of a constant, which must be a static field |
