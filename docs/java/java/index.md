---
title: Java
date: 2024-06-02 09:07:54
order: 1
---

## 计算机软硬件

计算机（Computer）：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。归纳一下，计算机的应用主要在以下几个方面：

- 科学计算：科学计算也称数值计算。计算机最开始是为解决科学研究和工程设计中遇到的大量数学问题的数值计算而研制的计算工具。例如，人造卫星轨迹的计算，房屋抗震强度的计算，火箭、宇宙飞船的研究设计都离不开计算机的精确计算。就连我们每天收听收看的天气预报都离不开计算机的科学计算。
- 数据处理：在科学研究和工程技术中，会得到大量的原始数据，其中包括大量图片、文字、声音等信息处理就是对数据进行收集、分类、排序、存储、计算、传输、制表等操作。
- 自动控制：自动控制是指通过计算机对某一过程进行自动操作，它不需人工干预，能按人预定的目标和预定的状态进行过程控制。例如，无人驾驶飞机、导弹、人造卫星和宇宙飞船等飞行器的控制，都是靠计算机实现的。
- 计算机辅助设计（Computer Aided Design，简称 CAD）：是指借助计算机的帮助，人们可以自动或半自动地完成各类工程设计工作。目前 CAD 技术已应用于飞机设计、船舶设计、建筑设计、机械设计、大规模集成电路设计等。在京九铁路的勘测设计中，使用计算机辅助设计系统绘制一张图纸仅需几个小时，而过去人工完成同样工作则要一周甚至更长时间。可见采用计算机辅助设计，可缩短设计时间，提高工作效率，节省人力、物力和财力，更重要的是提高了设计质量。
- 人工智能（Artificial Intelligence，简称 AI）：是指计算机模拟人类某些智力行为的理论、技术和应用。例如，用计算机模拟人脑的部分功能进行思维学习、推理、联想和决策，使计算机具有一定“思维能力”。我国已开发成功一些中医专家诊断系统，可以模拟名医给患者诊病开方。还有就是机器人也是计算机人工智能的典型例子。
- 多媒体应用：随着电子技术特别是通信和计算机技术的发展，人们已经有能力把文本、音频、视频、动画、图形和图像等各种媒体综合起来，构成一种全新的概念——“多媒体”（Multimedia）。比如一些 flash 广告，网页游戏等。
- 计算机网络：计算机网络是由一些独立的和具备信息交换能力的计算机互联构成，以实现资源共享的系统。如在全国范围内的银行信用卡的使用，火车和飞机票系统的使用等。

计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。计算机通常由 CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标，显示器等多个部件组成。

计算机软件（Computer Software）按照其功能可划分为系统软件与应用软件。它可以使计算机按照事先预定好的顺序完成特定的功能。系统软件：Windows、Linux、Mac、Android、iOS。应用软件：TIM、WeChat、WPS。

软件开发：借助开发工具与计算机语言制作软件。

- 软件：按照特定顺序组织的计算机数据和指令的集合
- 开发：软件的制作过程

## 计算机语言

计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。计算机语言中也有字符，符号等等。常见的计算机语言如 C、C++、C#、JAVA 等。

计算机软件都是用各种计算机语言编写的。最底层的叫**机器语言**，它由一些 0 和 1 组成，可以被某种电脑直接理解，但人就很难理解。上面一层叫**汇编语言**，它只能由某种电脑的汇编器软件翻译成机器语言程序后才能执行。人能够勉强理解汇编语言。人常用的语言是更上一层的**高级语言**，比如 C、C++、C#、Java 等。这些语言编写的程序一般都能在多种电脑上运行，但必须先由一个叫作编译器或者是解释器的软件将高级语言程序翻译成特定的机器语言程序。

- 机器语言：优点是最底层，速度最快。缺点是最复杂，开发效率最低。
- 汇编语言：优点是比较底层，速度最快。缺点是复杂，开发效率最低。
- 高级语言：
  - 编译型语言执行速度快，不依赖语言环境运行，跨平台差。
  - 解释型语言跨平台好，一份代码，到处使用，缺点是执行速度慢，依赖解释器运行。

![计算机语言](/svg/java/javase/index/language.svg)

::: info 计算机语言发展历史
自 1946 年 2 月 14 日世界上首款计算机 ENAC 问世，第一代计算机语言“机器语言”便诞生了。它使用的是最原始的穿孔卡片，这种卡片上使用的语言只有专家才能理解，与人类语言差别极大。这种语言本质上是计算机能识别的唯一语言，人类很难理解。

为了能让人们更容易理解并编写，于是便有了第二代的“汇编语言”。相比机器语言，汇编语言大大前进了一步，尽管它还是太复杂，人们在使用时很容易出错误，但毕竟许多数码已经开始用字母来代替。简单的"0"、"1"数字字符串人类来理解还是困难，但字母是人们能够阅读并拼写的。虽然第二代计算机语言仍然是“面向机器”的语言，但它已注定成为机器语言向更高级语言进化的桥梁。

当计算机语言发展到第三代时，就进入了“面向人类”的语言阶段。你可以阅读、并直接用人类的语言来输入。对我们汉语来说，目前还不能用中文汉字来输入指令，这主要是因为中文的输入还没有一个非常好的手段。第三代语言被人们称之为“高级语言”。高级语言是一种接近于人们使用习惯的程序设计语言。它允许用英文写计算程序，程序中所使用的运算符号和运算公式，都和我们日常用的数学公式差不多。高级语言容易学习，通用性强，书写出的程序比较短，便于推广和交流，是很理想的一种程序设计语言。我们学习的就是第三代语言“高级语言”中的 Java 语言。
:::

## CPU、内存、硬盘

程序是保存在硬盘中的，要载入内存才能运行。CPU 也被设计为只能从内存中读取数据和指令。对于 CPU 来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能。为了了解具体的运算过程，先看一下 CPU 的结构。CPU 是一个复杂的计算机部件，它内部又包含很多小零件。如下图：

![计算机硬件](/svg/java/javase/index/hardware.svg)

- 运算单元是 CPU 的大脑，负责加减乘除、比较、位移等运算工作。每种运算都有对应的电路支持，速度很快。
- 寄存器是 CPU 内部非常小、非常快速的存储部件。它可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记 CPU 的运行状态等。寄存器的容量有限：对于 32 的 CPU，每个寄存器一般能存储 32 位（4 个字节）的数据；对于 64 位的 CPU，每个寄存器一般能存储 64 位（8 个字节）的数据。为了完成各种复杂的功能，现代 CPU 都内置了几十个甚至上百个寄存器。嵌入式系统功能单一，寄存器数量较少。我们经常所说的多少位 CPU，指的是寄存器的位数。
- 缓存：CPU 内部为什么又要设置缓存呢？虽然内存的读取速度已经很快了，但是和 CPU 相比，还是有很大差距的。如果每次都从内存中读取数据，会严重拖慢 CPU 的运行速度，让 CPU 经常处于等待状态，无事可做。如果在 CPU 内部设置一个缓存，就可以将使用频繁的数据暂时读取到缓存。当需要同一地址上的数据时，就不用大老远的再去访问内存，直接从缓存中读取即可。缓存的容量是有限的，CPU 只能从缓存中读取到部分数据。对于使用不是很频繁的数据，会绕过缓存，直接到内存中读取。所以不是每次都能从缓存中得到数据，这就是缓存的命中率。能够从缓存中读取就命中，否则就没命中。关于缓存的命中率又是一门学问，哪些数据保留在缓存，哪些数据不保留，都有复杂的算法。

要想让 CPU 工作，必须借助特定的指令。例如 add 用于加法运算、sub 用于除法运算、cmp 用于比较两个数的大小……这称为 CPU 的指令集（Instruction Set）。我们的 C 语言代码最终也会编译成一条一条的 CPU 指令。不同型号的 CPU 支持的指令集会有所差异，但绝大部分是相同的。

## 程序运行流程

如果你的电脑上安装了 TIM，你希望和好友聊天，会双击 TIM 图标 → 打开 TIM 软件 → 输入账号和密码 → 点击登录按钮就可以了。那么 TIM 是怎么运行起来的呢？

双击 TIM 图标，操作系统就会知道你要运行这个软件，它会在硬盘中找到你安装的 TIM 软件，将数据（安装的软件本质上就是很多数据的集合）复制到内存。TIM 不是在硬盘中运行的，而是在内存中运行的。为什么呢？因为内存的读写速度比硬盘快很多。对于读写速度，内存 > 固态硬盘 > 机械硬盘。机械硬盘是靠电机带动盘片转动来读写数据的，而内存条通过电路来读写数据，电机的转速肯定没有电的传输速度（几乎是光速）快。虽然固态硬盘也是通过电路来读写数据，但是因为与内存的控制方式不一样，速度也不及内存。所以，不管是运行 TIM 还是编辑 Word 文档，都是先将硬盘上的数据复制到内存，才能让 CPU 来处理，这个过程就叫作**载入内存**（Load into Memory）。完成这个过程需要一个特殊的程序（软件），这个程序就叫做**加载器**（Loader）。CPU 直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。例如，打开 Word 文档，输入一些文字，虽然我们看到的不一样了，但是硬盘中的文档没有改变，新增的文字暂时保存到了内存，[[Ctrl]] + [[S]] 才会保存到硬盘。因为内存断电后会丢失数据，所以如果你编辑完 Word 文档忘记保存就关机了，那么你将永远无法找回这些内容。

如果电脑运行的程序较多，占用的空间就会超过内存（内存条）容量。例如计算机的内存容量为 2G，却运行着 10 个程序，这 10 个程序共占用 3G 的空间，也就意味着需要从硬盘复制 3G 的数据到内存，这显然是不可能的。操作系统为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘，需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据，这一部分空间就叫做**虚拟内存**（Virtual Memory）。3G - 2G = 1G，上面的情况需要在硬盘上分配 1G 的虚拟内存。硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现“卡死”现象，即使 CPU 强劲，也不会有大的改观。

## 采用二进制原因

首先，二进位计数制仅用两个数码：0 和 1，所以任何具有二个不同稳定状态的元件都可用来表示数的某一位，而在实际上具有两种明显稳定状态的元件很多。例如氖灯的“亮”和“熄”、开关的“开”和“关”、电压的“高”和“低”、“正”和“负”、纸带上的“有孔”和“无孔”、电路中的“有信号”和“无信号”、磁性材料的南极和北极等等，不胜枚举。利用这些截然不同的状态来代表数字，是很容易实现的。不仅如此，更重要的是两种截然不同的状态不单有量上的差别，而且是有质上的不同。这样就能大大提高机器的抗干扰能力，提高可靠性。而要找出一个能表示多于二种状态而且简单可靠的器件，就困难得多了。

其次，二进位计数制的四则运算规则十分简单，而且四则运算最后都可归结为加法运算和移位。这样，电子计算机中的运算器线路也变得十分简单了。不仅如此，线路简化了，速度也就可以提高。这也是十进位计数制所不能相比的。

第三，在电子计算机中采用二进制表示数可以节省设备。可以从理论上证明，用三进位制最省设备，其次就是二进位制。但由于二进位制有包括三进位制在内的其他进位制所没有的优点，所以大多数电子计算机还是采用二进制。此外，由于二进制中只用二个符号"0"和"1"，因而可用布尔代数来分析和综合机器中的逻辑线路，这为设计电子计算机线路提供了一个很有用的工具。

## Java 程序的执行流程

Java 是一种新型的跨平台分布式和程序设计语言。Java 以它简单、安全、可移植、面向对象、多线程处理和具有动态等特性引起世界范围的广泛关注。Java 语言是基于 C++ 的，其最大的特色在于“一次编写，处处运行”。Java 已逐渐成为网络化软件的核心语言。

语言处理程序的功能是将除机器语言以外，利用其他计算机语言编写的程序，转换成机器所能直接识别并执行的机器语言程序的程序。可以分为三种类型，即汇编程序、编译程序和解释程序。通常将汇编语言及各种高级语言编写的计算机程序称为源程序（Source Program），而把由源程序经过翻译（汇编或者编译）而生成的机器指令程序称为目标程序（Object Program）。

语言处理程序中的汇编程序与编译程序具有一个共同的特点：必须生成目标程序，然后通过执行目标程序得到最终结果。而解释程序（脚本语言）是对源程序进行解释（逐句翻译），翻译一句执行一句，边解释边执行，从而得到最终结果。解释程序不产生将被执行的目标程序，而是借助解释程序直接执行源程序本身。

## Java 语言发展史

- 20 世纪 90 年代，硬件领域出现了单片机式计算机系统。这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品（例如：电视机顶盒、面包烤箱、移动电话等）的智能化进度。Sun 公司为了抢占先机，在 1991 年成立了一个名为"Green"（类似于绿色软件的意思）的项目小组，James Gosling、Patrick Naughton、Michael Sheridan 和其他几个同事们一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面开始研究开发新技术，专攻计算机语言在消费类电子产品上嵌入式应用。
- 由于 C++ 所具有的优势，该项目组的研究人员首先考虑采用 C++ 来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++ 所编写的程序过于庞大和复杂。另外由于消费类电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序跨平台运行也是个难题。为了解决困难，他们首先着眼于计算机语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范。其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后能有半导体芯片生产商开发和生产这种硬件平台。对于新语言的设计，Sun 公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对 C++ 进行了改造，去除了 C++ 上的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发出了一个名为"Oak"的面向对象语言。
- 由于在开发 Oak 语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比 C++ 更加简单之外，没有太大区别。1992 年的夏天，当 Oak 语言开发成功后，研究者们向硬件生产商进行演示了 Green 操作系统、Oak 程序设计语言、类库和其硬件，以说服他们对 Oak 语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对 Oak 语言还是一无所知的情况下就贸然生产硬件产品的风险实在是太大了，所以 Oak 语言也就因此缺乏硬件的支持而无法进入市场，从而被搁置了下来。
- 1994 年 6、7 月间，在经历了一场历时三天的讨论后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网上。他们认为随着 Mosaic 浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，Patrick Naughton 编写了一个小型万维网浏览器 WebRunner。
- 1995 年，互联网的蓬勃发展给了 Oak 机会。业界为了使死板、单调的静态页面能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大 IT 企业为此纷纷投入了巨大的人力、物力与财力。这个时候，Sun 公司想起了那个被搁置很久的 Oak，并且重新审视了那个用软件编写的实验平台，由于它是按照嵌入式系统硬件平台体系结构所进行编写的，所以非常小，特色适用于网络上传输，而 Oak 也是一种精简的语言，程序非常小，适合在网络上传输。Sun 公司首先推出了可以嵌入网页并且可以随同网页在网络上传输 Applet（一种将小程序嵌入到网页中进行执行的技术），并将 Oak 更名为"Java"。从此一个即好听又好记、具有强大的生命力的编程语言 Java 便诞生了。
- 在申请商标的时候也有这样一件趣事，Sun 公司在申请 Oak 商标时发现 Oak 已经被别家公司使用了，所以 James Gosling 决定通过市场部门，请来了一个命名顾问，召开命名征集会。在命名征集会上，大家提出了很多名字。最后按大家的评选次序，将十几个名字排列成表，上报给商标律师。排在第一位的是 Silk（丝绸）。尽管大家都喜欢这个名字，但遭到 James Gosling 的坚决反对而作罢。排在第二和第三的都没有通过律师这一关。James Gosling 最喜欢的就是排在第三位的 Lyric（抒情诗）。只有排在第四位的名字得到了所有人的认可和律师的通过，这个名字就是"Java"。那么是谁在命名征集会上提议叫"Java"的呢？Jame Gosling 在接受采访时回忆道：“市场部组织了命名会，命名顾问主持了会议，我们喊叫着列出了一大堆名字。我记得第一个提议 Java 这个名字的是 Mark Opperman。Mark Opperman 是在一家名叫“爪蛙咖啡”的咖啡店与同事品尝咖啡时得到灵感的。Java 是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。国外的许多咖啡店用 Java 来命名或宣传，以彰显其咖啡的品质。Java 语言中的许多库类名称，多与咖啡有关，如 JavaBeans（咖啡豆）、NetBeans（网络豆）以及 ObjectBeans （对象豆）等等。

## Java 的版本历史

- 1995 年 5 月 23 日，Sun 在 Sun World 会议上正式发布 Java 语言和 HotJava 浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape 和 Microsoft 等各大公司都纷纷停止了自己的相关开发项目，竞相购买了 Java 使用许可证，并为自己的产品开发了相应的 Java 平台。
- 1996 年 1 月，Sun 公司发布了 Java 的第一个开发工具包（JDK1.0），这是 Java 发展历程中的重要里程碑，标志着 Java 成为一种独立的开发工具。
- 1996 年 4 月，10 个最主要的操作系统供应商申明将在其产品中嵌入 Java 技术。
- 1996 年 9 月，约 8.3 万个网页应用了 Java 技术来制作。
- 1996 年 10 月，Sun 公司发布了 Java 平台第一个即时编译器（JIT）。
- 1997 年 2 月 18 日，JDK1.1 面世，在随后的三周时间里，达到了 22 万次的下载量。
- 1997 年 4 月 2 日，JavaOne 会议召开，参与者逾一万人，创当时全球同类会议规模之纪录。
- 1997 年 9 月，JavaDeveloperConnection 社区成员超过十万。
- 1998 年 2 月，JDK1.1 被下载超过 2,000,000 次。
- 1998 年 12 月 8，Java 的企业平台 Java EE 正式发布。
- 1999 年 6 月，Sun 公司发布第二代 Java 的三大版本：标准版 J2SE（Java2 Standard Edition）：应用于桌面环境、企业版 J2EE（Java2 Enterprise Edition）：应用于基于 Java 的应用服务器、微型版 J2ME（Java2 Micro Edition）：应用于移动、无线及有限资源的环境。Java2 的发布，标志着 Java 的应用开始普及，是 Java 发展历程中的又一个里程碑。
- 1999 年 4 月 27 日，HotSpot 虚拟机发布。HotSpot 虚拟机发布时是作为 JDK1.2 的附加程序提供的，后来它成为了 JDK1.3 及之后所有版本的 Sun JDK 的默认虚拟机。
- 2000 年 5 月 8 日，JDK1.3 发布。
- 2000 年 5 月 29 日，JDK1.4 发布。获得 Apple 公司 Mac OS 的工业标准的支持。
- 2001 年 6 月 5 日，NOKIA 宣布，到 2003 年将出售 1 亿部支持 Java 的手机。
- 2001 年 9 月 24 日，Java EE 1.3 发布。
- 2002 年 2 月 26 日，J2SE1.4 发布，自此 Java 的计算能力有了大幅提升，与 J2SE1.3 相比，其多了近 62%的类与接口。在这些新特性当中，还提供了广泛的 XML 支持、安全套接字（Socket）支持（通过 SSL 与 TLS 协议）、全新的 I/OAPI、正则表达式、日历与断言。
- 2004 年 9 月 30 日 18:00PM，J2SE1.5 发布，是 Java 语言发展史上的又一里程碑事件。为了表示这个版本的重要性，J2SE 1.5 正式更名为 Java SE 5.0（内部版本号：1.5.0），代号"Tiger"该版本是自 1996 年发布 1.0 版本以来最大的更新，其中包括泛型的支持、基本数据类型的自动装箱、改进的循环、枚举类型、格式化 I/O 及可变参数。
- 2005 年 6 月，在 Java One 大会上，Sun 公司发布了 Java SE 6。此时，Java 的各个版本都已经更名，去掉了前些版本中的数字 2，改为了 Java。
- 2006 年 11 月 13 日，Sun 公司宣布，将 Java 技术作为免费的软件对外发布。Sun 公司正式发布 Java 平台标准版的第一批源代码，以及 mini 版本的可执行源代码。一直以来，Sun 公司维持着大约 2 年发布一次 JDK 新版本的习惯。
- 2007 年 3 月，自起，全世界所有的开发人员均可对 Java 源代码进行修改。
- 2009 年 4 月 20 日，Oracle 宣布将以每股 9.5 美元的价格收购 Sun，该交易的总价值约为 74 亿美元。但 Oracle 通过收购 Sun 公司获得了两项软件资产：Java 和 Solaris。于是曾经代表一个时代的公司：Sun 倒下了，不过 Java 的大旗依然“猎猎”作响。2007 年 11 月，Google 宣布推出一款基于 Linux 平台的开源手机操作系统：Android。Android 的出现顺应了即将出现的移动互联网潮流，而且 Android 系统的用户体验非常好，因此迅速成为手机操作系统的中坚力量。Android 平台使用了 Dalvik 虚拟机来运行.dex 文件，Dalvik 虚拟机的作用类似于 JVM 虚拟机，只是它并未遵守 JVM 规范而已。Android 使用 Java 语言来开发应用程序，这也给了 Java 语言一个新的机会。在过去的岁月中，Java 语言作为服务器端编程语言，已经取得了极大地成功；而 Android 平台的流行，则让 Java 语言获得了在客户端程序上大展拳脚的机会。
- 2010 年 Java 编程语言的创始人 James Gosling 从 Oracle 公司辞职。
- 2011 年 7 月 28 日，Oracle 公司终于发布了 Java 7，这次版本升级经过了将近 5 年时间。Java 7 也是 Oracle 发布的第一个 Java 版本，引入了二进制整数、支持字符串的 switch 语句、菱形语法、多异常捕捉、自动关闭资源的 try 语句等新特性。
- 2014 年 3 月 18 日，Oracle 公司发布了 Java 8，这次版本升级为 Java 带来了全新的 Lambda 表达式。除此之外，Java 8 还增加了大量新特性，这些新特性使得 Java 变得更加强大。
- 2017 年 9 月 21 日，Java 9 发布。该版本支持：模块化（jiqsaw）、交互式命令行（JShell）、默认垃圾回收期切换为 G1、进程操作改进、竞争锁性能优化、分段代码缓存和优化字符串占用空间等新特性。
- 2018 年 3 月 21 日，Java 10 发布。
- 2018 年 9 月 25 日，Java 11 发布。
- ……

## JDK 与 JRE 之间的关系

| 工具 | 说明                                                             | 英文名                   |
| ---- | ---------------------------------------------------------------- | ------------------------ |
| JVM  | Java 虚拟机：真正运行 Java 程序的地方                            | Java Virtual Machine     |
| JDK  | Java 开发工具：包含 Java 编译器、Java 虚拟机以及 Java 核心类库等 | Java Development Kit     |
| JRE  | Java 运行时环境：只包含 Java 虚拟机以及 Java 核心类库            | Java Runtime Environment |

- JDK：JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具（javac.exe）打包工具（jar.exe）等。
- JRE：包括 Java 虚拟机（JVM Java Virtual Machine）和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。

**JDK、JRE、JVM 的关系：**

- JVM：Java 虚拟机
- JRE：Java 运行环境 `JRE = JVM + 类库`
- JDK：Java 开发环境 `JDK = JRE + JAVA的开发工具`

::: info 为什么 JDK 中包含一个 JRE 呢？

- 其一，开发完的程序，总需要运行一下看看效果。
- 其二，也是最重要的，JDK 中的开发工具其实都是 java 语言编写的应用程序，为了方便使用才打包成 exe 文件，如果没有 JRE，那么这些工具是运行不了的。

:::

## Java 的跨平台性

因为有了 JVM，所以同一个 Java 程序在三个不同的操作系统中都可以执行。这样就实现了 Java 程序的跨平台性。也称为 Java 具有良好的可移植性。Java 之所以能跨平台有两个原因：

- Java 文件经过编译后生成和平台无关的 class 文件
- Java 虚拟机（JVM）是不跨平台的

![跨平台](/svg/java/javase/index/platform.svg)

在这里进行编译操作的工具叫做 `javac` 命令，启动 JVM 并把字节码加载进 JVM 的工具叫做 `java` 命令。

- 编写源文件（Java 文件），源文件中包含源代码（Java 代码）
- 使用 javac 工具对源文件做编译操作，进行语法检查。语法：`javac 源文件.java`
- 生成字节码后，使用 java 工具启动 JVM，运行程序。语法：`java 拥有主方法的类名`
- 在控制台输出，显示结果

![编译过程](/svg/java/javase/index/compilation.svg)

## Java 语言特性

::: tabs
== 简单性

> 我们希望构建一个无须深奥的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。因此，尽管我们发现 C++ 不太适用，但在设计 Java 的时候还是尽可能地接近 C++，以便系统更易于理解。Java 剔除了 C++ 中许多很少使用、难以理解、容易混淆的特性。在我们看来，这些特性带来的麻烦远远多于它们的好处。

的确，Java 语法是 C++ 语法的一个“纯净”版本。这里没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等。然而，设计者并没有试图清除 C++ 中所有不适当的特性。例如，switch 语句的语法在 Java 中就没有改变。如果你了解 C++，就会发现可以轻而易举地转换到 Java 语法。

> “简单”的另一个方面是小。Java 的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为 40KB，再加上基础的标准类库和对线程的支持（基本上是一个自包含的微内核），大约需要增加 175KB。

在当时，这是一个了不起的成就。当然，由于不断的扩展，类库已经相当庞大了。现在有一个独立的具有较小类库的 Java 微型版（Java Micro Edition），这个版本适用于嵌入式设备。
== 面向对象

> 简单地讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。用木匠打一个比方：一个“面向对象的”木匠始终首先关注的是所制作的椅子，其次才是所使用的工具；一个“非面向对象的”木匠主要考虑的是所用的工具。在本质上，Java 的面向对象能力与 C++ 是一样的。

开发 Java 时面向对象技术已经相当成熟。Java 的面向对象特性与 C++ 旗鼓相当。Java 与 C++ 的主要不同点在于多重继承，在 Java 中，取而代之的是更简单的接口概念。与 C++ 相比，Java 提供了更丰富的运行时自省功能。
== 分布式

> Java 有一个丰富的例程库，用于处理像 HTTP 和 FTP 之类的 TCP/IP 协议。Java 应用程序能够通过 URL 打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。

如今，这一点被认为是理所当然的，不过在 1995 年，主要还是从 C++ 或 Visual Basic 程序连接 Web 服务器。
== 健壮性

> Java 的设计目标之一在于使得 Java 编写的程序具有多方面的可靠性。Java 非常强调进行早期的问题检测、后期动态的（运行时）检测，以及消除容易出错的情况……Java 与 C/C++ 最大的不同在于 Java 采用的指针模型可以消除重写内存和损坏数据的可能性。

Java 编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。至于第二点，对于曾经花费几个小时来检查由于指针 bug 而引起内存冲突的人来说，一定很喜欢 Java 的这一特性。
== 安全性

> Java 要适用于网络/分布式环境。为了实现这个目标，安全性颇受重视。使用 Java 可以构建防病毒、防墓改的系统。

从一开始，Java 就设计成能够防范各种攻击，其中包括：

- 运行时堆栈溢出，这是蠕虫和病毒常用的攻击手段
- 破坏自己的进程空间之外的内存
- 未经授权读写文件

原先，Java 对下载代码的态度是“尽管来吧！”。不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。用户可以确信不会发生不好的事情，因为 Java 代码不论来自哪里，都不能脱离沙箱。

不过，Java 的安全模型很复杂。Java 开发包（Java Development Kit, JDK）的第一版发布之后不久，普林斯顿大学的一些安全专家就发现一些小 bug 会允许不可信的代码攻击主系统。

最初，安全 bug 可以快速修复。遗憾的是，经过一段时间之后，黑客已经很擅长找出安全体系结构实现中的小漏洞。Sun 以及之后的 Oracle 为不断修复 bug 经历了一段很是艰难的日子。

遭遇多次高调攻击之后，浏览器开发商和 Oracle 开始越来越谨慎。Java 浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码。

注释：现在看来，尽管 Java 安全模型没有原先预想的那么成功，但 Java 在那个时代确实相当超前。微软提供了一种与之竞争的代码交付机制，其安全性完全依赖于数字签名。显然这是不够的，因为微软自身产品的任何用户都可以证实，一些知名开发商的程序确实会崩溃并对系统产生危害。
== 体系结构中立

> 编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有 Java 运行时系统，这些编译后的代码可以在许多处理器上运行。Java 编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地转换成本地机器代码。

当时，为“虚拟机”生成代码并不是一个新思路。诸如 Lisp、Smalltalk 和 Pascal 等编程语言多年前就已经采用了这种技术。

当然，解释型虚拟机指令肯定会比全速运行机器指令慢很多。不过，虚拟机有一个选项，可以将执行最频繁的字节码序列转换成机器码，这一过程称为即时编译。

Java 虚拟机还有一些其他优点。它可以检查指令序列的行为，从而增强其安全性。
== 可移植性

> 与 C 和 C++ 不同，Java 规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算的行为都有明确的说明。

例如，Java 中的 int 永远为 32 位的整数，而在 C/C++ 中，int 可能是 16 位整数、32 位整数，也可能是编译器开发商指定的任何其他大小。唯一的限制只是 int 类型的字节数不能低于 shortint，并且不能高于 longint。在 Java 中，数值类型有固定的字节数，这消除了代码移植时一个令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串则采用标准的 Unicode 格式存储。

> 作为系统组成部分的类库，定义了可移植的接口。例如，有一个抽象的 Window 类，并给出了在 UNIX、Windows 和 Macintosh 环境下的不同实现。

选择 Window 类作为例子可能并不太合适。凡是尝试过的人都知道，要编写一个在 Windows、Macintosh 和 10 种不同风格的 UNIX 上看起来都不错的程序有多么困难。Java 1.0 就尝试着做了这么一个壮举，发布了一个简单的工具包，为多个不同平台提供了常用的用户界面元素。遗憾的是，尽管花费了大量的心血，结果却不尽如人意，这个库并不能提供在不同系统上都让人接受的结果。原先的用户界面工具包已经重写，而且后来又再次重写，不过跨平台的可移植性仍然是个问题。

不过，除了与用户界面有关的部分外，所有其他 Java 库确实能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，JavaAPI 往往也比原生 API 质量更高。
== 解释性

> Java 解释器可以在任何移植了解释器的机器上直接执行 Java 字节码。由于连接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。

这看上去很不错。用过 Lisp、Smalltalk、Visual Basic、Python、R 或 Scala 的人都知道“快捷而且具有探索性”的开发过程是怎样的。你可以做些尝试，然后就能立即看到结果。在 Java 发展的前 20 年里，开发环境并没有把重点放在这种体验上。直到 Java9 才提供了 jshell 工具支持快捷而且具有探索性的编程。
== 高性能

> 尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更高的性能。字节码可以（在运行时）动态地转换成对应运行这个应用的特定 CPU 的机器码。

使用 Java 的头几年，许多用户不同意“对性能已经比较满意”的说法。不过，现在的即时编译器已经非常出色，可以与传统编译器相娩美，而且在某些情况下甚至超越了传统编译器，原因是它们有更多的可用信息。例如，即时编译器可以监控哪些代码频繁执行，并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集合，如果一个特定的函数不会被覆盖，就可以使用内联。必要时，以后还可以撤销这种优化。
== 多线程

> 多线程可以带来更快的交互响应和实时行为。

如今，我们非常关注并发性，因为摩尔定律即将走到尽头。我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。不过，可以看到，大多数编程语言对于这个问题并没有显示出足够的重视。

Java 在当时很超前。它是第一个支持并发程序设计的主流语言。从白皮书中可以看到，它的出发点稍有些不同。当时，多核处理器还很神秘，而 Web 编程才刚刚起步，处理器要花很长时间等待服务器响应，需要并发程序设计来确保用户界面不会“冻住”。并发程序设计绝非易事，不过 Java 在这方面表现很出色，可以很好地管理这个工作。
== 动态性

> 从很多方面来看，Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在 Java 中找出运行时类型信息十分简单。

当需要为正在运行的程序增加代码时，动态性将是一个非常重要的特性。一个很好的例子是：从 Internet 下载代码，然后在浏览器上运行。如果使用 C 或 C++，这确实难度很大，不过 Java 设计者很清楚动态语言可以很容易地实现运行程序的演进。最终，他们将这一特性引入这个主流程序设计语言中。
:::

## JDK 版本与语言特性

| 版本      | 年份         | 新语言特性                                                              |
| --------- | ------------ | ----------------------------------------------------------------------- |
| `JDK 1.0` | 1996 年      | 语言本身                                                                |
| `JDK 1.1` | 1997 年      | 反射、内部类、新的事件处理模型                                          |
| `JDK 1.2` | 1998 年      | GUI、strictfp 修饰符；推出 3 个版本:JavaSE/JavaEE/JavaME                |
| `JDK 1.3` | 2000 年      | 无                                                                      |
| `JDK 1.4` | 2002 年      | 断言                                                                    |
| `JDK 5.0` | 2004 年      | for-each 循环、自动装箱、枚举、注解、泛型、可变元参数、元数据、静态导入 |
| `JDK 6`   | 2006 年      | 无                                                                      |
| `JDK 7`   | 2011 年      | 基于字符串的选择语句、菱形运算符、二进制字面量、异常处理增强            |
| `JDK 8`   | 2014 年      | lambda 表达式、流、包含默认方法的接口、日期/时间库                      |
| `JDK 9`   | 2017 年      | 模块、其他的语言和类库增强                                              |
| `JDK 10`  | 2018 年 3 月 |                                                                         |
| `JDK 11`  | 2018 年 9 月 |                                                                         |
| `JDK 12`  | 2019 年 3 月 |                                                                         |
| `JDK 13`  | 2019 年 9 月 |                                                                         |
| `JDK 14`  | 2020 年 3 月 |                                                                         |
| `JDK 15`  | 2020 年 9 月 |                                                                         |
| `JDK 16`  | 2021 年 9 月 |                                                                         |
| `JDK 17`  | 2021 年 9 月 |                                                                         |
| `JDK 18`  | 2022 年 3 月 |                                                                         |
| `JDK 19`  | 2022 年 9 月 |                                                                         |
| `JDK 20`  | 2023 年 3 月 |                                                                         |
| `JDK 21`  | 2023 年 9 月 |                                                                         |

## HelloWorld

编写 HelloWorld 的步骤：

- 首先编写 java 源代码程序：`HelloWorld.java`
- 在命令行模式中，输入 javac 命令对源代码进行编译，生成字节码文件：`javac HelloWorld.java`
- 编译完成后，如果没有报错信息，输入 java 命令对 class 字节码文件进行解释运行：`java HelloWorld`

```java
package org.example;

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("hello world!");
  }
}
```

### HelloWorld 代码详解

- `package`：包管理。出现在程序最开始的地方（零条或一条）
- `import`：引入 Java 提供的类/API（零条或多条）
- `class`：定义一个类。表明 Java 程序中的全部内容都包含在类中。注意：公开类的类名必须跟文件名保持一致
- `public`：是访问修饰符。由于 main 方法是被 JVM 调用的，所以权限要够大
- `static`：静态的。不需要创建对象，通过类名就可以，方便 JVM 的调用
- `void`：因为方法的返回值是返回给调用者用的，而 main 方法是被 JVM 调用的，反回内容给 JVM 没有意义
- `main`：执行 Java 程序的入口。它有三个修饰符：public、static、void。它也可以接收命令行参数
- `String[] args`：字符串数组，早期是为了接收键盘录入数据。例如：`java HelloWorld hello world`
- `{}`：左花括号表示代码块的开始；右花括号表示代码块的结束
- `语句`：每个语句都是以分号 `;` 作为结束的
- `注释`：包括三种注释类型（行注释、块注释、文档注释）

### HelloWorld 基本语法

- Java 语言严格区分大小写。好比 main 和 Main、system 和 System 是完全不同的概念。
- 一个源文件可以存在多个类。一个源文件最好只包含一个 public 公共类。若源文件中包括了 public 类，源文件的文件名必须与公共类的名字相同。
- 一个源文件中包含 N 个类时，成功编译后会生成 N 份字节码文件。即每个类都会生成一份单独的 class 文件，且字节码文件名和其对应的类名相同。
- Java 程序是支持跨平台的，而且它的工作方式是：先编译再解释执行程序代码。
  - 源文件经过 javac 编译器编译后，生成对应平台的字节码文件（.class 文件）。
  - 当使用 java 解释器运行已编译的字节码文件时，JVM 总是从指定类中的 main 方法的代码开始执行。因此为了代码能够执行，在类的源文件中必须包含一个 main 方法。

## 进制转换

进制：就是进位制，是人们规定的一种进位方法。对于任何一种进制（X 进制），就表示某一位置上的数运算是逢 X 进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。

二进制的由来：任何数据在计算机中都是以二进制的形式存在的，二进制早期由电信号开关演变而来。计算机的电子原件的状态是开、关，那么我们在表达数据的时候，也是按照开、关的状态来表示的。

![电路开关](/svg/java/javase/index/switchs.svg)

如果我们表达数据仅仅用这两种状态，那么能够表达的数据是比较少的。而我们常见的数据，英文字母、数字、标点符号等就很多了。因此只有这两个状态肯定是不够的。为了能够表示更多的数据，国际化标准组织就规定，用 8 个这样的信号来表示一个数据，这个数据就叫做：字节 `byte`。这个时候我们把上面的数据用 1 和 0 做改进，由此这样的 1 和 0 组成的数据就是二进制数据。

但是，使用一大串的 1 或 0 组成的数值进行使用是很麻烦的，所以就想要简化一下。如何进行简化呢？

把二进制的数据，从右开始，三位用一位表示，且这三位可以取到的最大值就是 7，超过 7 就要进位了。最左边不够的时候，补 0。然后分别计算出对应的十进制数值，把每个十进制的数据组合起来，就可以得到一个八进制数据，这就是八进制。但是对于过长的二进制变成八进制还是较长，所以出现的用 4 个二进制位表示一位的情况，四个二进制位最大是 15，这就是十六进制。由下表可得出规律：进制越大，表现形式越短。

![二进制转其他进制](/svg/java/javase/index/binary.svg)

### 不同进制的数据表现

- 二进制（BIN）：由 0、1 组成，以 `0b` 开头
- 八进制（OCT）：由 0、1、2、3、4、5、6、7 组成，以 `0` 开头
- 十进制（DEC）：由 0、1、2、3、4、5、6、7、8、9 组成，默认整数是十进制
- 十六进制（HEX）：由 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 组成，以 `0x` 开头（大小写均可）

任意的 X 进制到 Y 进制转换的方法：

- X 进制转换成十进制
- 十进制转换成 Y 进制

::: info 8421 码
8421 码是 bcd 码的一种，它表示每一个二进制位上的数据对应一个固定的值，只需要把对应的 1 位置的数据值给相加，即可得到该二进制对应的十进制的值。

|---|---|---|---|---|---|---|---|---|
| 二进制 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 十进制 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |

- 二进制到十进制的转换：1010100 = 64 + 16 + 4 = 84
- 十进制到二进制的转换：100 = 0b1100100

:::

::: tabs
== 案例：二进制到八进制

```
方式一：
1. 二进制转换成十进制：0b1011001 = 64 + 16 + 8 + 1 = 89
2. 十进制转换成八进制：89 = 0131
      89 = 89 / 8 = 11    1
           11 / 8 = 1     3
           1  / 8 = 0     1

方式二：0b1011001 = 0131
     001 011 001
       1   3   1
```

== 案例：二进制到十六进制

```
方式一：
1. 二进制转换成十进制：0b1011001 = 64 + 16 + 8 + 1 = 89
2. 十进制转换成十六进制：89 = 0x59
      89 = 89 / 16 = 5    9
            5 / 16 = 0    5

方式二：0b1011001 = 0x59
       0101 1001
          5    9
```

:::

### 其他进制到十进制的转换

```
12345 = 10000 + 2000 + 300 + 40 + 5
12345 = 1*10^4 + 2*10^3 + 3*10^2 + 4*10^1 + 5*10^0
```

其他进制到十进制的转换：每一个位上的系数 \* 基数 ^权次幂^ 相加

- 系数：每一个位上的数据值本身就是系数
- 基数：X 进制的基数就是 X
- 权：针对每一个位上的数据进行编号，从右边，并且是从 0 开始编号，这个编号就是该位上数据的权值

<!-- prettier-ignore-start -->
|X 进制 |100 转换过程 |十进制|
|--|--:|--|
|二进制 |100 = 1 * 2^2^ + 0 * 2^1^ 0 * 2^0^ | 4|
|^^| = 4 + 0 + 0|^^|
|^^| = 4|^^|
|八进制 |100 = 1 * 8^2^ + 0 * 8^1^ 0 * 8^0^ | 64|
|^^| = 64 + 0 + 0|^^|
|^^| = 64|^^|
|十六进制 |100 = 1 * 16^2^ + 0 * 16^1^ 0 * 16^0^ | 256|
|^^| = 256 + 0 + 0|^^|
|^^| = 256|^^|
<!-- prettier-ignore-end -->

### 十进制到其他进制的转换

十进制到其他进制：除基取余，直到商为 0，余数反转。

![十进制转其他进制](/svg/java/javase/index/decimal.svg)

### 原码、反码、补码

有符号数据的表示法：原码、反码和补码。计算机在操作的时候，所有数据的运算都是采用对应数据的二进制补码进行计算的。

案例：+7 和 -7 的原码、反码、补码。首先得到 7 的二进制：`111`

- 原码：就是二进制定点表示法，即最高位为符号位，"0" 表示正，"1" 表示负，其余位表示数值的大小。

|     | 符号位 | 数位值  |
| --- | ------ | ------- |
| +7  | 0      | 0000111 |
| -7  | 1      | 0000111 |

- 反码：正数的反码与原码相同；负数的反码与原码符号位相同，数值位取反

|     | 符号位 | 数位值  |
| --- | ------ | ------- |
| +7  | 0      | 0000111 |
| -7  | 1      | 1111000 |

- 补码：正数的补码与原码相同；负数的补码是在反码的基础上加 1

|     | 符号位 | 数位值  |
| --- | ------ | ------- |
| +7  | 0      | 0000111 |
| -7  | 1      | 1111001 |
